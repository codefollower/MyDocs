因为看到这篇文章中的问题 http://weibo.com/p/1001603915623099946931

所以想尝试用[Lealone早期的事务模型](https://github.com/lealone/Lealone-Docs/blob/master/%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/%E4%BA%8B%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.md)来解决它

假设有两台db server: s1、s2， **分布式事务用奇数版本号**
## 一个转账业务的例子:

a账户放在s1，a的初值是100，a的版本号是0
b账户放在s2，b的初值是100，b的版本号是0

现在有一个分布式事务要执行转账业务，执行下面两个操作:
a=a-10
b=b+10

无论分布式事务成功或失败，不能违反下面的约束:
a+b=200
并且每次读出a和b的值时都满足a+b=200

以下所说的本地事务不管是读还是写，都是某个分布式事务的一部分，
也就是说如果分布式事务包含两个本地写事务，它们要么都成功要么都失败；
如果分布式事务包含两个本地读事务，如果是串行执行它们，
不会出现第一个本地读事务读到的是旧值而第二个本地读事务读到新值的情况。
###### 转账过程：

(1). 在s1上面启动本地事务s1-t1，执行a=a-10=90， a的版本号变成1

(2). 在s2上面启动本地事务s2-t1，执行b=b+10=110，b的版本号变成1

(3). 得到一个本地事务列表[s1-t1,s2-t1]

(4). 把[s1-t1,s2-t1]发给s1, 让它提交本地事务s1-t1，提交时间戳是3, 
   并把一条事务状态记录写到本地事务状态表中，这条事务状态记录如下:

``` javascript
   本地事务id  提交时间戳  本地事务id列表
   -------------------------------------------
   s1-t1       3           [s1-t1,s2-t1]
```

(5) . 把[s1-t1,s2-t1]发给s2, 让它提交本地事务s2-t1，提交时间戳是3, 
   并把一条事务状态记录写到本地事务状态表中，这条事务状态记录如下:

``` javascript
   本地事务id  提交时间戳  本地事务id列表
   -------------------------------------------
   s2-t1       3           [s1-t1,s2-t1]
```

(6). 成功提交后，a、b账户如下

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   a    s1          90   1
   a    s1          100  0

   b    s2          110  1
   b    s2          100  0 
   ------------------------------
```
###### 统计过程(一个本地事务成功提交，另一个失败的场景)：

(1). 建立本地读事务s1-t5，读出a账户最新的记录

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   a    s1          90   1
```

   把所属server和版本号组合成s1-t1，并用s1-t1读本地事务状态表，

``` javascript
   本地事务id  提交时间戳  本地事务id列表
   -------------------------------------------
   s1-t1       3           [s1-t1,s2-t1]
```

   因为s1-t5比3大，所以取出[s1-t1,s2-t1]后继续到s2中验证本地事务s2-t1是否提交成功，
   如果在s2的本地事务状态表中找不到与s2-t1对应的记录，说明分布式事务是无效的，
   此时a账户的有效值是100，否则是90

(2). 建立本地读事务s2-t5，读出b账户最新的记录，过程与1一样。
   如果分布式事务是无效的，此时b账户的有效值是100，否则是110

(3). 所以，无论哪个失败，都满足a+b=200

上面所说的场景是本地读事务[s1-t5,s2-t5]在本地写事务[s1-t1,s2-t1]之后进行

下面描述另一种场景:
本地读事务穿插在本地写事务之间

假设a、b账户初始如下:

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   a    s1          100  0
   b    s2          100  0 
   ------------------------------
```

(1). 建立本地读事务s1-t1，读出a账户的记录

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   a    s1          100  0
```

(2). 两个本地写事务[s1-t3,s2-t1]在a、b账户之间执行转账操作，成功后a、b账户如下

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   a    s1          90   3
   a    s1          100  0

   b    s2          110  1
   b    s2          100  0 
   ------------------------------
```

   s2中的本地事务状态表:

``` javascript
   本地事务id  提交时间戳  本地事务id列表
   -------------------------------------------
   s2-t1       3           [s1-t3,s2-t1]
```

(3). 建立本地读事务s2-t5，读出b账户最新的记录

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   b    s2          110  1
```

   把所属server和版本号组合成s2-t1，并用s2-t1读本地事务状态表，得到如下记录:

``` javascript
   本地事务id  提交时间戳  本地事务id列表
   -------------------------------------------
   s2-t1       3           [s1-t3,s2-t1]
```

   此时读到的本地事务id列表是[s1-t3,s2-t1]，
   但是在第1步中读到的a账户的版本号是0，而这里是s1-t3，说明a账户被改过了，
   不能读b账号的最新值，所以要读b账号上一次的值，也就是初始值100，
   所以a+b还是等于200
## 最后一个问题:

如何处理分布式事务与普通事务(非分布式事务)同时出现的情况？
如何达到全局的snapshot isolation？

**普通事务用偶数版本号**

假设a、b账户初始如下:

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   a    s1          100  0
   b    s2          100  0 
   ------------------------------
```

(1). 在s1启动一个普通写事务s1-t2，执行a=a+10，a、b账户变成:

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   a    s1          110  2
   a    s1          100  0

   b    s2          100  0 
   ------------------------------
```

(2). 建立本地读事务s1-t3，读出a账户最新的记录

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   a    s1          110  2
```

   从第1步a、b账户的快照看，
   接下来应该读到b账户的下面这条记录才满足全局的snapshot isolation:

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   b    s2          100  0 
```

(3). 两个本地写事务[s1-t5,s2-t1]在a、b账户之间执行转账操作，成功后a、b账户如下

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   a    s1          100  5
   a    s1          110  2
   a    s1          100  0

   b    s2          110  1
   b    s2          100  0 
   ------------------------------
```

   s2中的本地事务状态表:

``` javascript
   本地事务id  提交时间戳  本地事务id列表
   -------------------------------------------
   s2-t1       3           [s1-t5,s2-t1]
```

(4). 建立本地读事务s2-t3，读出b账户最新的记录

``` javascript
   账户 所属server  值   版本号
   ------------------------------
   b    s2          110  1
```

   把所属server和版本号组合成s2-t1，并用s2-t1读本地事务状态表，得到如下记录:

``` javascript
   本地事务id  提交时间戳  本地事务id列表
   -------------------------------------------
   s2-t1       3           [s1-t5,s2-t1]
```

   此时读到的本地事务id列表是[s1-t5,s2-t1]，
   但是在第2步中读到的a账户的版本号是2，而这里是s1-t5，说明a账户被改过了，
   不能读b账号的最新值，所以要读b账号上一次的值，也就是初始值100，满足全局的snapshot isolation。

